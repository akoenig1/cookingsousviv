{"ast":null,"code":"function t(t) {\n  return t && \"object\" == typeof t && \"default\" in t ? t.default : t;\n}\n\nvar r = require(\"react\"),\n    n = t(require(\"media-typer\")),\n    e = t(require(\"content-type\"));\n\n\"undefined\" != typeof Symbol && (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))), \"undefined\" != typeof Symbol && (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))), module.exports = function (t, o) {\n  var u = r.useState({\n    data: null,\n    loading: 0,\n    error: null,\n    controller: null\n  }),\n      i = u[0],\n      a = u[1],\n      l = r.useRef(!1);\n  return r.useLayoutEffect(function () {\n    return l.current = !0, function () {\n      l.current = !1;\n    };\n  }, []), r.useEffect(function () {\n    var r = new AbortController();\n    return t && function (t, r, o, u) {\n      void 0 === r && (r = {});\n\n      try {\n        var i = Object.assign({}, r, {\n          signal: o.signal\n        }),\n            a = null;\n        Promise.resolve(function (r, l) {\n          try {\n            var s = (u(function (t) {\n              return {\n                data: null,\n                loading: t.loading + 1,\n                error: null,\n                controller: o\n              };\n            }), Promise.resolve(fetch(t, i)).then(function (t) {\n              function r() {\n                if (!a.ok) {\n                  var t = new Error(a.statusText);\n                  throw t.status = a.status, t;\n                }\n              }\n\n              var o = (a = t).headers.get(\"content-type\"),\n                  i = function () {\n                if (o) {\n                  function t() {\n                    u(function (t) {\n                      return Object.assign({}, t, {\n                        data: r,\n                        loading: t.loading - 1\n                      });\n                    });\n                  }\n\n                  var r = null,\n                      i = function (t) {\n                    if (t) {\n                      var r = e.parse(t),\n                          o = n.parse(r.type);\n                      if (\"json\" === o.subtype) return !0;\n                      if (\"json\" === o.suffix) return !0;\n                      if (o.suffix && /\\bjson\\b/i.test(o.suffix)) return !0;\n                      if (o.subtype && /\\bjson\\b/i.test(o.subtype)) return !0;\n                    }\n\n                    return !1;\n                  }(o) ? Promise.resolve(a.json()).then(function (t) {\n                    r = t;\n                  }) : Promise.resolve(a.text()).then(function (t) {\n                    r = t;\n                  });\n                  return i && i.then ? i.then(t) : t();\n                }\n\n                u(function (t) {\n                  return Object.assign({}, t, {\n                    loading: t.loading - 1\n                  });\n                });\n              }();\n\n              return i && i.then ? i.then(r) : r();\n            }));\n          } catch (t) {\n            return l(t);\n          }\n\n          return s && s.then ? s.then(void 0, l) : s;\n        }(0, function (t) {\n          var r = \"AbortError\" !== t.name ? t : null;\n          u(function (t) {\n            return Object.assign({}, t, {\n              error: r,\n              loading: a ? t.loading : t.loading - 1\n            });\n          });\n        }));\n      } catch (t) {\n        return Promise.reject(t);\n      }\n    }(t, o, r, function (t) {\n      l.current && a(t);\n    }), function () {\n      return r.abort();\n    };\n  }, [o, t]), {\n    data: i.data,\n    loading: !!i.loading,\n    error: i.error,\n    abort: function () {\n      return i.controller && i.controller.abort();\n    }\n  };\n};","map":{"version":3,"sources":["../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../src/index.ts","../src/fetchData.ts","../src/isJSON.ts"],"names":["Symbol","iterator","asyncIterator","body","recover","result","e","then","url","init","useState","data","loading","error","controller","isMounted","useRef","useLayoutEffect","current","useEffect","AbortController","fetchData","state","setState","abort","actualInit","Object","signal","rsp","oldState","fetch","contentTypeHeader","headers","get","isJSON","json","text","ok","err","Error","statusText","status","name","ct","contentType","parse","mediaType","mediaTyper","type","subtype","suffix","test"],"mappings":"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","sourcesContent":["// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","import { useState, useEffect, useLayoutEffect, useRef } from 'react';\r\n\r\nimport { FetchState, AbortableFetchResult } from './types';\r\nimport fetchData from './fetchData';\r\n\r\nconst useAbortableFetch = <T>(\r\n  url: string | null,\r\n  init?: RequestInit\r\n): AbortableFetchResult<T> => {\r\n  const [state, setState] = useState<FetchState<T>>({\r\n    data: null,\r\n    loading: 0,\r\n    error: null,\r\n    controller: null\r\n  });\r\n\r\n  const isMounted = useRef(false);\r\n  useLayoutEffect((): (() => void) => {\r\n    isMounted.current = true;\r\n    return (): void => {\r\n      isMounted.current = false;\r\n    };\r\n  }, []);\r\n\r\n  useEffect((): (() => void) => {\r\n    const controller = new AbortController();\r\n    if (url) {\r\n      fetchData<T>(url, init, controller, (state): void => {\r\n        if (isMounted.current) {\r\n          setState(state);\r\n        }\r\n      });\r\n    }\r\n\r\n    return (): void => controller.abort();\r\n  }, [init, url]);\r\n\r\n  return {\r\n    data: state.data,\r\n    loading: !!state.loading,\r\n    error: state.error,\r\n    abort: (): null | void => state.controller && state.controller.abort()\r\n  };\r\n};\r\n\r\nexport default useAbortableFetch;\r\n","import { Dispatch, SetStateAction } from 'react';\r\n\r\nimport { FetchState } from './types';\r\nimport isJSON from './isJSON';\r\n\r\nconst fetchData = async <T>(\r\n  url: string,\r\n  init: RequestInit = {},\r\n  controller: AbortController,\r\n  setState: Dispatch<SetStateAction<FetchState<T>>>\r\n): Promise<void> => {\r\n  const actualInit: RequestInit = { ...init, signal: controller.signal };\r\n\r\n  let rsp: Response | null = null;\r\n  try {\r\n    setState(\r\n      (oldState: FetchState<T>): FetchState<T> => ({\r\n        data: null,\r\n        loading: oldState.loading + 1,\r\n        error: null,\r\n        controller\r\n      })\r\n    );\r\n\r\n    rsp = await fetch(url, actualInit);\r\n    const contentTypeHeader = rsp.headers.get('content-type');\r\n\r\n    if (contentTypeHeader) {\r\n      let data: T | string | null = null;\r\n\r\n      if (isJSON(contentTypeHeader)) {\r\n        data = await rsp.json();\r\n      } else {\r\n        data = await rsp.text();\r\n      }\r\n      setState(\r\n        (oldState: FetchState<T>): FetchState<T> => ({\r\n          ...oldState,\r\n          data,\r\n          loading: oldState.loading - 1\r\n        })\r\n      );\r\n    } else {\r\n      setState(\r\n        (oldState: FetchState<T>): FetchState<T> => ({\r\n          ...oldState,\r\n          loading: oldState.loading - 1\r\n        })\r\n      );\r\n    }\r\n\r\n    if (!rsp.ok) {\r\n      const err: any = new Error(rsp.statusText);\r\n      err.status = rsp.status;\r\n      throw err;\r\n    }\r\n  } catch (e) {\r\n    const err: Error = e;\r\n\r\n    const error = err.name !== 'AbortError' ? err : null;\r\n\r\n    setState(\r\n      (oldState: FetchState<T>): FetchState<T> => ({\r\n        ...oldState,\r\n        error,\r\n        // Only decrease the loading counter if there is no repsonse\r\n        loading: rsp ? oldState.loading : oldState.loading - 1\r\n      })\r\n    );\r\n  }\r\n};\r\n\r\nexport default fetchData;\r\n","import mediaTyper from 'media-typer';\r\nimport contentType from 'content-type';\r\n\r\nexport default function isJSON(\r\n  contentTypeHeader: string | null | undefined\r\n): boolean {\r\n  if (contentTypeHeader) {\r\n    const ct = contentType.parse(contentTypeHeader);\r\n\r\n    const mediaType = mediaTyper.parse(ct.type);\r\n\r\n    if (mediaType.subtype === 'json') {\r\n      return true;\r\n    }\r\n\r\n    if (mediaType.suffix === 'json') {\r\n      return true;\r\n    }\r\n\r\n    if (mediaType.suffix && /\\bjson\\b/i.test(mediaType.suffix)) {\r\n      return true;\r\n    }\r\n\r\n    if (mediaType.subtype && /\\bjson\\b/i.test(mediaType.subtype)) {\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n}\r\n"]},"metadata":{},"sourceType":"script"}